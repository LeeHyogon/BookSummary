# 3.1 어째서 캐시가 필요한 것인가?

- 디스크는 액추에이터(톤암)를 움직여서 데이터를 읽고 씁니다. 오라클은 디스크에게 읽고 쓰는 것을 의뢰한다. 
- 오라클은 여러 개의 프로세스로 구성되어 있고 SQL문을 동시에 처리할 수 있다.
- 또한 프로세스에는 각자의 역할이 있으며, SQL문을 빠르게 처리하는 서버프로세스와 그것을 지원하는 백그라운드 프로세스가 존재한다..
- 1장에서 디스크가 동작하는 것은 매우 느리고 I/O 1회에 10~ 20 ms 정도 걸린다고 언급. 그래서 오라클은 '캐시'라고 불리는 기술을 사용해 가능한한 메모리에서 처리하는 구조를 갖고 있다.

# 3.2 그래서 캐시란 무엇인가?

- 디스크의 데이터를 처리해야 할 때 메모리(캐시)에 같은 데이터가 존재하면 디스크에서 읽을 필요 없이 CPU에게 데이터를 직접 건네줄 수 있음.
- CPU캐시는 속도가 빠르지만 가격이 가장 비싸다. 지금 나오는 캐시(메모리)와는 관계가 없다.

다음으로 오라클에서 데이터 캐시(버퍼 캐시) 동작을 보자.
- 서버 프로세스가 원하는 데이터가 버퍼 캐시에 존재할 때 데이터를 빠르게 꺼내와서 처리가능. 없다면 데이터를 디스크에서 읽어 옴

# 3.3 데이터는 블록 단위로 관리
- 오라클은 '블록'이라고 하는 단위로 데이터를 관리한다.
- I/O의 단위도 블록을 기반으로 하고 있으며, 버퍼 캐시도 블록 단위로 관리하고 있다. 오라클에서 말하는 블록은 OS의 블록이 아니라 독자적인 블록을 말한다.

# 3.4 캐시를 사용해서 인덱스 검색을 효율적으로
- 테이블뿐만 아니라 인덱스도 블록으로 구성. 인덱스를 한 블록에 보관할 수 없을 때는 여러 개의 블록으로 구성. 

# 3.5 프로세스는 캐시를 공유
- 프로세스마다 캐시를 가지면 낭비가 많아지고, 다른 프로세스에서 변경된 데이터를 볼 수 없는 등, 여러 문제가 발생. 그래서 어떠한 오라클 프로세스라도 볼 수 있는 메모리를 캐시로 활용함.
- OS에서 다른 프로세스의 메모리를 보는 것은 기본적으로 불가능. OS가 메모리 안의 데이터를 손상되지 않도록 보호하고 있기 때문. 이러면 DBMS 입장에서 불편함이 발생할 수 밖에 없으므로, OS는 '공유 메모리'라는 특수한 메모리 기능을 제공한다. 공유 메모리를 사용하면 자신의 메모리 영역에 기록했던 데이터를 다른 프로세스에서도 즉시 볼 수 있다.
- 공유 메모리를 이해하기 위한 중요 포인트는 '실제 메모리는 한 개다' 라는 개념.
- 각 프로세스에게는 마치 자신의 메모리인 것처럼 보이지만, 실제로는 모든 프로세스가 같은 메모리 영역에 접근하고 있는 것. 오라클에서른 이런 공유 메모리를 'SGA(System Global Area)', 공유하지 않는 메모리의 일부를 'PGA(Program Global Area)'라고 부른다.
- DBMS에게 공유 메모리는 매우 편리한 도구이자, 다수 프로세스로 구성되므로 필수 기능. 하지만 공유 메모리에 누구든지 접근할 수 있으므로 Lock을 걸어 배타적 제어를 해야 함.
- DBMS가 Lock이 복잡하게 얽힌 내부 구조를 가지므로, 성능 문제가 발생하기 쉽다.

# 3.8 버퍼 캐시를 정리하는 LRU 알고리즘
- 버퍼 캐시는 자주 사용하는 데이터를 더 빠르게 가져오기 위해 존재. 또한, 버퍼 캐시의 크기는 한정되어 있으므로, 누군가가 어떤식으로 관리해야 함.
- 일반적으로 오라클은 LRU알고리즘을 사용
- 오라클은 LRU를 토대로 블록의 목록을 가지고 있으며, 어떤 블록이 최근에 사용되지 않았는지를 파악하고 있다. 데이터를 읽어오는 것만이라면 이 동작으로도 충분하지만, 오라클의 서버 프로세스는 변경한 데이터(블록)도 캐시에 둔다. 서버 프로세스는 디스크에 기록을 하지 않기 때문에 백그라운드 프로세스의 DBWR가 정기적으로 변경한 데이터를 디스크에 부하를 주지 않도록 조심하면서 디스크에 저장.
- 변경한 데이터는 디스크에 기록하기 전에 캐시에서 버리면 데이터가 손실되므로, 캐시에서 버려지기 전에 디스크에 기록해둠.
- 데이터가 많은 테이블을 풀 스캔한 데이터는 적재해두더라도 사용하는 경우가 별로 없고, 자주 사용하는 데이터를 캐시에서 쫓아내는 일이 발생하므로 오라클은 큰 테이블이라고 판단하면 버퍼 캐시로 블록을 적재하지 않으며, 풀 스캔했을 때의 데이터는 일반적으로 버퍼 캐시에 적재되지 않는다.

# 3.9 오라클뿐만이 아닌 OS나 스토리지에 대해서도 생각하자
- 쓸 때: 스토리지의 캐시에 데이터를 기록하면 OS의 관점에서는 I/O는 종료
- 읽을 때: 스토리지의 캐시에 적재되어 있다면 즉시 응답
- 스토리지의 캐시에 기록한 데이터가 유실되어서는 안되므로, 이중화나 비휘발성 메모리를 사용하는 등의 장치가 고안됨. 그래서 스토리지 캐시는 가격이 높다.

![image](https://github.com/LeeHyogon/BookSummary/assets/45483116/61ce1750-3e6e-4168-a65c-28545b6664c1)

## 3.9.1 OS의 버퍼 캐시와 가상 메모리의 차이
- OS에는 버퍼 캐시(파일 캐시나 페이지캐시라고도 부름)와 가상 메모리라고 불리는 기능이 있다. 이 두 가지 기능과 오라클의 버퍼 캐시는 같은 것으로 생각해야 함.
- OS의 버퍼 캐시는 오라클의 버퍼 캐시와 비슷한 기능을 가지고 있다.
![image](https://github.com/LeeHyogon/BookSummary/assets/45483116/762e831e-ee96-45e0-9043-97807fb3f5a5)
![image](https://github.com/LeeHyogon/BookSummary/assets/45483116/a1391c75-cebb-407c-90f9-d67daab65ad8)
- OS에서는 가상 메모리 기능을 이용해 실제 물리 메모리보다 더 많은 메모리를 사용할 수 있다. 이 기능은 메모리에서 자주 사용되지 않느 데이터를 디스크에 저장. 프로세스 관점에선 메모리 저장이지만, 실제로는 디스크에 저장된 구성
- 그림 3-16의 1,3 동작을 페이징이라고 하며, 이는 물리 메모리와 디스크 사이에서 블록(페이지)을 주고 받는 것을 의미
- 물리 메모리의 페이지를 디스크에 기록하는 것을 페이지 아웃(page out), 디스크의 페이지를 물리메모리로 읽어오는 것을 페이지 인
- 가상 메모리는 버퍼 캐시와는 반대로 동작하도록 구현되어 있음.
- 버퍼 캐시(OS든 오라클이든)는 디스크에 빠르게 접근하기 위해 메모리의 일정 부분을 할당하여 사용.

#### 예시
오라클의 버퍼 캐시를 물리 메모리보다 많게 설정한다고 가정했을 때, 가상 메모리를 사용해서 버퍼 캐시를 물리 메모리보다 크게 설정할 수는 있지만, 의도했던 바를 실제로 달성한 걸까? 
**그렇지 않다**<br>
왜나하면 버퍼 캐시를 사용하여 메모리를 고속화한다는 목적이 페이징으로 인해 상쇄되어 버리기 때문. 물론 OS의 버퍼 캐시도 마찬가지.
![image](https://github.com/LeeHyogon/BookSummary/assets/45483116/9a14d8cb-9446-40b9-9286-97f95e3ffefb)

- 최근에는 메모리가 저렴하므로 물리 메모리를 충분히 할당한 후, 오라클이 물리 메모리만 사용할 수 있도록 파라미터를 설정할 것을 권장. 가상메모리는 사용하지 않기를..
- 이 내용을 잘 지킨다면 시스템에서도 캐시가 쾌적하게 작동할 것.

# 3.10 요약
Q. 오라클에서 같은 성능 테스트를 반복 수행 시, 첫번째 테스트가 종료 한 후 캐시를 정리하기 위해 오라클을 재기동했더니 두 번째의 테스트에서는 속도가 더 빨라짐. 왜 그럴까?
<br> A. OS의 버퍼 캐시에 데이터가 적재되어 있기 때문.
- 만약 테스트 결과가 안 좋은 경우는 한번이었으니 특이사항이 없다고 넘긴다면, 잘못된 대처이다.

