# 9.1 개요
- DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분

## 9.1.1 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

1. SQL 파싱
- 첫 번째 단계를 "SQL 파싱(Parsing)"이라고 하며, MySQL 서버의 "SQL 파서"라는 모듈로 처리한다. 
- SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다. 또한 이 단계에서 "SQL 파스 트리"가 만들어진다.
- MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.

2. 최적화 및 실행 계획 수립(옵티마이저에서 처리)
- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

## 9.1.2 옵티마이저 - 비용 기반 최적화
옵티마이저는 DB서버에서 두뇌와 같은 역할을 담당
- 비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 비용 산출.

# 9.2 기본 데이터 처리
MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다. 하지만 RDBMS별로 결과 산출 과정은 천차만별.

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
MySQL 옵티마이저가 풀 테이블 스캔 선택하는 경우
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 더 빠른 경우
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 **리드 어헤드** 작업이 자동으로 시작된다. 
리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.

풀 테이블이 스캔 실행 -> 몇개의 데이터 페이지는 포그라운드 스레드가 조회 -> 특정 시점부터 백그라운드 스레드가 조회해서 버퍼 풀에 저장. -> 포그라운드 스레드는 버퍼 풀에 준비된 데이터를 가져다 사용하므로 쿼리 처리가 빨리 처리됨.

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다. 

## 9.2.2 병렬 처리
- MyySQL 8.0 버전에서는 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬 처리 가능
- CPU 코어 개수를 넘어서는 경우 오히려 성능이 떨어질 수도 있으니 주의

## 9.2.3 ORDER BY 처리(Using filesort)

### 인덱스 이용

#### 장점
- INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름
#### 단점
- INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 많이 필요.

### Filesort 이용

#### 장점
- 인덱스를 생성하지 않아도 됨
- 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름.
#### 단점
0 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상건수가 많아질수록 쿼리 응답 속도가 느림.


#### 인덱스 튜닝하여 정렬하기 힘든 경우
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### 9.2.3.1 소트 버퍼
MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다. 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.

정렬이 문제가 되는 부분
- 레코드의 건수가 소트 버퍼로 할당된 공간보다 큰경우? -> 레코드를 여러 조각으로 나눠서 처리하는데 이 과정에서 임시 저장을 위해 디스크를 사용.
- 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔다. 그리고 다음 레코드를 가져와 다시 정렬해서 반복적으로 디스크에 임시 저장.
- 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행하는 것을 **멀티 머지** 라고 표현.

이 작업들이 모드 디스크의 쓰기와 읽기를 유발. 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아짐. 소트 버퍼를 크게 설정해도 속도는 큰 차이가 없다.
소트 버퍼의 크기를 10MB 이상으로 설정하면 커넥션당 소트 버퍼를 가져가므로, OS가 메모리 부족현상을 겪고, OOM-Killer가 메모리를 가장 많이 사용하는 MySQL 서버를 강제 종료 시킬 수 있다. 


### 9.2.3.2 정렬 알고리즘

- 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 2가지 정렬 모드로 나눌 수 있다.

#### 3가지 정렬 방식

- <sort_key, rowid>: 정렬 키와 레코드의 Row ID만 가져와서 정렬하는 방식
- <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
- <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈로 메모리 저장

첫 번쨰 방식을 투 패스 정렬 방식 2,3번쨰 방식을 싱글패스라 명명하자.

#### 9.2.3.2.1 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식

``` sql
SELCT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```
![image](https://github.com/LeeHyogon/BookSummary/assets/45483116/0b1d0901-334d-4ac7-bf08-392c6730f366)

위 쿼리와 같이 first_name으로 정렬해서 emp_no, first_name, last_name을 SELECT하는 쿼리를 싱글 패스 정렬 방식으로 처리하는 절차를 그림
처음 emplyees 테이블을 읽을 때 정렬에 필요하지 않은 last_name 칼럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행.

#### 9.2.3.2.2 투 패스 정렬 방식

![image](https://github.com/LeeHyogon/BookSummary/assets/45483116/cd3d2673-de5e-43ad-8354-9d1ca752e4e7)

정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식
- 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 상당히 불합리하지만, 새로운 정렬 방식인 싱글 패스는 이러한 불합리가 없다. 하지만 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하다.

일반적으로 싱글 패스 정렬 방식을 주로 사용.
but, 다음과 같은 경우 투 패스 정렬 방식을 사용
- 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때


### 9.2.3.3 정렬 처리 방법
|정렬 처리 방법|실행 계획의 Extra 칼럼 내용|
|---|---|
|인덱스를 사용한 정렬 |별도 표기x|
|조인에서 드라이빙 테이블만 정렬|"Using filesort"|
|조인에서 조인 결과를 임시 테이블로 저장 후 정렬|"Using temporary; Using filesort"|

인덱스 정렬을 사용할 수 없다면 
- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

#### 9.2.3.3.1 인덱스를 이용한 정렬

R-Tree, 전문 검색 인덱스, 해시 인덱스 등에서는 인덱스 정렬 사용 불가.
여러 테이블이 조인되는 경우는 Nested-loop 방식의 조인만 이 방식을 사용 가능.

인덱스를 이용한 정렬 조회는 정렬 추가 작업 없이 순서대로 읽는다.

![image](https://github.com/LeeHyogon/BookSummary/assets/45483116/d510fc3e-18c9-49ab-9b37-593abce48d73)

조인이 Nested-loop 방식으로 실행되므로 조인 떄문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다. 하지만 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수도 있다.

#### 드라이빙 테이블 선택 기준(참고)
- 인덱스를 이용한 액세스 방식 > 전체 테이블 액새스 방식
- 조인 칼럼에대한 인덱스가 양쪽 모두 존재 시 레코드 수가 작은 테이블을 드라이빙 테이블 선택
- 조인 칼럼에만 인덱스가 존재하는 경우 인덱스가 없는 테이블을 드라이빙, 인덱스가 있는 테이블을 드리븐
- 두 칼럼 모두 인덱스가 없는 경우, 스캔되는 레코드 수에 따라 적절히 드라이빙 테이블 선택

#### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어나고, 레코드 하나하나의 크기도 늘어남. 그래서 조인 실행 전에 첫 번쨰 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책.
``` sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
AND e.emp_no BETWEEN 10002 AND 10010
ORDER BY e.last_name;
```
- WHERE절 조건으로 employees 테이블 레코드 건수가 적음.
- 드리븐 테이블의 조인 칼럼인 emp_no칼럼에 인덱스가 있음.


#### 9.2.3.3.3 임시 테이블을 이용한 정렬

``` sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
AND e.emp_no BETWEEN 10002 AND 10010
ORDER BY s.salary;
```
- 정렬이 수행되기 전에 salaries 테이블(드리븐 테이블)을 읽어야 하므로 이 쿼리는 조인된 데이터를 가지고 정렬함.
   
#### 9.2.3.3.4 정렬 처리 방법의 성능 비교
주로 웹 서비스용 쿼리에서는 ORDER BY와 함께 LIMIT이 거의 필수로 사용되는 경향이 있다. 그러나 ORDER BY, GROUP BY같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서는 처리할 수 없다. 우선 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 비로소 LIMIT으로 건수를 제한할 수 있다.

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동하는지 살펴보자

#### 9.2.3.3.4.1 스트리밍 방식
- 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
- 스트리밍 방식으로 처리되는 쿼리에서 LIMIT처럼 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줌. 매우 큰 테이블을 아무런 조건 없이 SELECT만 해보면 첫 번째 레코드는 아주 빨리 가져온다는 사실을 알 수 있다.

#### 9.2.3.3.4.2 버퍼링 방식
- OEDER BY, GROUP BY 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다. MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다. 그렇기 때문에 이 방식을 스트리밍의 반대 표현으로 버퍼링이라고 표현.
- MYSQL서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때 까지 기다림. LIMIT처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 안됨.
- ORDER BY의 3가지 처리 방법 가운데 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링된 후에 정렬된다. 즉 인덱스를 사용한 정렬 방식은 LIMIT으로 제한된 건수만큼 읽으면서 바로바로 클라이언트로 결과를 전송해 줄 수 있다.하지만 인덱스를 사용하지 못하는 경우의 처리는 필요한 모든 레코드를 디스크로부터 읽어서 정렬한 후에야 비로스 LIMIT으로 제한된 건수만큼 잘라서 클라이언트로 전송해 줄 수 있음을 의미한다.

``` sql
SELECT *
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1=t2.col1
ORDER BY t1.col2
LIMIT 10;
```

가정
- tb_test1테이블의 레코드는 100건, tb_test2 테이블 레코드는 1000건(tb_test1의 레코드 1건당 tb_test2의 레코드는 10건).
- 두 테이블의 조인 결과는 전체 1000건.

#### tb_test1이 드라이빙 되는 경우

|정렬  방법|읽어야 할 건수|조인 횟수|정렬해야 할 대상 건수|
|---|---|---|---|
|인덱스 사용 |tb_test1: 1건 <br> tb_test2:10건 |1번|0건|
|조인에서 드라이빙 테이블만 정렬|tb_test1: 1000건 <br> tb_test2:10건 |1번|100건(tb_test1 테이블의 레코드 건수)|
|임시 테이블 사용 후 정렬|tb_test1: 100건 <br> tb_test2:1000건 |100번(tb_test1 테이블의 레코드 건수만큼 조인 발생)|1,000건(조인된 결과 레코드 건수를 전부 정렬)|


#### tb_test2이 드라이빙 되는 경우

|정렬  방법|읽어야 할 건수|조인 횟수|정렬해야 할 대상 건수|
|---|---|---|---|
|인덱스 사용 |tb_test2: 10건 <br> tb_test1:10건 |10번|0건|
|조인에서 드라이빙 테이블만 정렬|tb_test2: 1000건 <br> tb_test1:10건 |10번|1000건(tb_test2 테이블의 레코드 건수)|
|임시 테이블 사용 후 정렬|tb_test2: 1000건 <br> tb_test1:100건 |1000번(tb_test2 테이블의 레코드 건수만큼 조인 발생)|1,000건(조인된 결과 레코드 건수를 전부 정렬)|

- 어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만, 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이. 가능하면 인덱스 정렬, 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 튜닝.

> 인덱스를 사용하지 못해도 LIMIT 조건이 아무런 도움이 되지 못하는 건 아니다. 정렬할 대상 레코드가 1,000건인 쿼리에 LIMIT 10이라는 조건이 있따면 상위 10건만 정렬이 채워지면 정렬을 멈추고 결과를 반환한다. 하지만 MySQL서버는 퀵소트와 힙 소트알고리즘을 사용하므로 상위 10건을 정렬하기 위해 더 많은 작업이 필요할 수도 있다. 결론적으로 인덱스를 사용하지 못하는 쿼리를 페이징 처리하더라도 쿼리가 기대만큼 빨라지지 않음.

## 9.2.4 GROUP BY 처리

- GROUP BY 절이 있는 쿼리에서는 HAVING절을 사용할 수 있는데, HAVING 절은 GROUP BY 결과에 대해 필터링 역할을 수행함. GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING절을 튜닝하려고 인덱스를 생성하거나 다른 방법 고민할 필요x.
- GROUP BY 작업 인덱스 스캔 방법과 루스 인덱스 스캔이라는 방법이 있따.
- 인덱스를 사용하지 못하는 쿼리는 임시 테이블을 사용한다.

### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
- ORDER BY의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때, GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹 함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다. GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블은 필요하지 않다.
- 이러한 그루핑 방식을 사용하면 Extra 칼럼에 별도로 코멘트가 표시되지 않는다.
### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
- 루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미
- Extra칼럼에 "Using index for group-by" 코멘트가 표시된다.

``` sql
EXPLAIN
   SELECT emp_no
   FROM salaries
   WHERE from_date='1985-03-01'
   GROUP BY emp_no;
```
salaries 테이블의 인덱스 (emp_no, from_date)로 생성되어 있으므로 위의 쿼리 문장에서 WHERE 조건은 인덱스 레인지 스캔 접근 방식으로 이용x. 그러나 실행 계획은 range 타입을 이용했으며, GROUP BY 처리까지 인덱스를 사용가능.

why?
1. (emp_no, from_date) 인덱스를 차례대로 스캔하면서 emp_no "10001"을 찾아냄.
2. (emp_no, from_date) 인덱스에서 emp_no가 '10001'인 것 중에서 from_date값이 '1985-03-01'인 레코드만 가져옴.
3. 다음 유니크 키 가져와서 끝날때까지 반복

### 9.2.4.3 임시 테이블을 사용하는 GROUP BY
- GROUP BY 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 인덱스를 전혀 사용하지 못하는 방식인 경우 이 방식으로 처리.

``` sql
EXPLAIN
   SELECT e.last_name, AVG(s.salary)
   FROM employees e, salaries s
   WHERE s.emp_no=e.emp_no
   GROUP BY e.last_name;
```
이 쿼리의 실행 계획에서는 Extra 칼럼에 "Using temporary" 메시지가 표시됨.
이 실행 계획에서 임시 테이블이 사용된 것은 employees 테이블을 full scan해서가 아님. 인덱스를 전혀 사용할 수 없는 GROUP BY이기 때문.

- MySQL 8.0 에서는 GROUP BY가 필요한 경우 내부적으로 GROUP BY 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다.
- 즉, 위의 쿼리를 처리하기 위해 다음과 같은 임시 테이블을 생성하고 조인의 결과를 한 건씩 가져와 임시 테이블에서 중복 체크 하면서 INSERT, UPDATE를 실행. 즉 별도의 정렬 작업x.

``` sql
CREATE TEMPORARY TABLE ...(
   last_name VARCHAR(16),
   salary INT,
   UNIQUE INDEX ux_lastname (last_name)
);
```











