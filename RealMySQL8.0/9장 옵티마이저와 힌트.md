# 9.1 개요
- DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분

## 9.1.1 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

1. SQL 파싱
- 첫 번째 단계를 "SQL 파싱(Parsing)"이라고 하며, MySQL 서버의 "SQL 파서"라는 모듈로 처리한다. 
- SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다. 또한 이 단계에서 "SQL 파스 트리"가 만들어진다.
- MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.

2. 최적화 및 실행 계획 수립(옵티마이저에서 처리)
- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

## 9.1.2 옵티마이저 - 비용 기반 최적화
옵티마이저는 DB서버에서 두뇌와 같은 역할을 담당
- 비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 비용 산출.

# 9.2 기본 데이터 처리
MySQL 서버를 포함한 모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다. 하지만 RDBMS별로 결과 산출 과정은 천차만별.

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
MySQL 옵티마이저가 풀 테이블 스캔 선택하는 경우
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 더 빠른 경우
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 **리드 어헤드** 작업이 자동으로 시작된다. 
리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.

풀 테이블이 스캔 실행 -> 몇개의 데이터 페이지는 포그라운드 스레드가 조회 -> 특정 시점부터 백그라운드 스레드가 조회해서 버퍼 풀에 저장. -> 포그라운드 스레드는 버퍼 풀에 준비된 데이터를 가져다 사용하므로 쿼리 처리가 빨리 처리됨.

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다. 

## 9.2.2 병렬 처리
- MyySQL 8.0 버전에서는 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬 처리 가능
- CPU 코어 개수를 넘어서는 경우 오히려 성능이 떨어질 수도 있으니 주의

## 9.2.3 ORDER BY 처리(Using filesort)

### 인덱스 이용

#### 장점
- INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름
#### 단점
- INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 많이 필요.

### Filesort 이용

#### 장점
- 인덱스를 생성하지 않아도 됨
- 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름.
#### 단점
0 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상건수가 많아질수록 쿼리 응답 속도가 느림.


#### 인덱스 튜닝하여 정렬하기 힘든 경우
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### 9.2.3.1 소트 버퍼
MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다. 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.

정렬이 문제가 되는 부분
- 레코드의 건수가 소트 버퍼로 할당된 공간보다 큰경우? -> 레코드를 여러 조각으로 나눠서 처리하는데 이 과정에서 임시 저장을 위해 디스크를 사용.
- 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록해 둔다. 그리고 다음 레코드를 가져와 다시 정렬해서 반복적으로 디스크에 임시 저장.
- 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행하는 것을 **멀티 머지** 라고 표현.

이 작업들이 모드 디스크의 쓰기와 읽기를 유발. 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아짐. 소트 버퍼를 크게 설정해도 속도는 큰 차이가 없다.
소트 버퍼의 크기를 10MB 이상으로 설정하면 커넥션당 소트 버퍼를 가져가므로, OS가 메모리 부족현상을 겪고, OOM-Killer가 메모리를 가장 많이 사용하는 MySQL 서버를 강제 종료 시킬 수 있다. 


### 9.2.3.2 정렬 알고리즘































